#pragma kernel CSBlurHorizontal
#pragma kernel CSBlurVertical

#define DEF_ThreadCount 256 
#define DEF_BlurSigma 9

#define CacheSize DEF_ThreadCount + DEF_BlurSigma
groupshared float3 _gsCache[CacheSize];

Texture2D<float3>   _Source;
RWTexture2D<float3> _Output_Horizontal;
RWTexture2D<float3> _Output_Vertical;

StructuredBuffer<unorm float> _Weights;//This


[numthreads(DEF_ThreadCount,1,1)]
void CSBlurHorizontal   (uint3 groupID           : SV_GroupID, 
                         uint groupIndex         : SV_GroupIndex, 
                         uint3 groupThreadID     : SV_GroupThreadID, 
                         uint3 dispatchThreadId  : SV_DispatchThreadID)
{
    uint2 sourceSize;
    _Source.GetDimensions(sourceSize.x, sourceSize.y);
    int2 sourceUV = dispatchThreadId.xy;
    sourceUV.x = min(sourceUV.x, sourceSize.x -1);
    sourceUV.y = min(sourceUV.y, sourceSize.y -1);

    int blurRadius = (DEF_BlurSigma - 1) * 0.5f;
    _gsCache[groupThreadID.x + blurRadius] = _Source[sourceUV];
    if (groupThreadID.x < (uint)blurRadius) 
    {
        sourceUV.x = max(sourceUV.x - blurRadius, 0);    
        _gsCache[groupThreadID.x] = _Source[sourceUV]; 
    }
    else if (groupThreadID.x >= DEF_ThreadCount - (uint)blurRadius) 
    {
        sourceUV.x = min(sourceUV.x + blurRadius, sourceSize.x - 1); 
        _gsCache[groupThreadID.x + 2 * blurRadius] = _Source[sourceUV];
    }

    GroupMemoryBarrierWithGroupSync(); 

    float3 col = 0.0f;
    [unroll(DEF_BlurSigma)]
    for (int i = 0; i < DEF_BlurSigma; i++)
    {
        col += _gsCache[groupThreadID.x + i] * _Weights[i];
    }
   
    _Output_Horizontal[uint2(dispatchThreadId.x, dispatchThreadId.y)] = col;
}


[numthreads(1,DEF_ThreadCount,1)]
void CSBlurVertical     (uint3 groupID           : SV_GroupID, 
                         uint groupIndex         : SV_GroupIndex, 
                         uint3 groupThreadID     : SV_GroupThreadID, 
                         uint3 dispatchThreadId  : SV_DispatchThreadID)
{ 
    uint2 sourceSize;
    _Source.GetDimensions(sourceSize.x, sourceSize.y);
    int2 sourceUV = dispatchThreadId.xy;
    sourceUV.x = min(sourceUV.x, sourceSize.x -1);
    sourceUV.y = min(sourceUV.y, sourceSize.y -1);

     int blurRadius = (DEF_BlurSigma - 1) * 0.5f;
    _gsCache[groupThreadID.y + blurRadius] = _Source[sourceUV];
    if (groupThreadID.y < (uint)blurRadius) 
    {
        sourceUV.y = max(sourceUV.y - blurRadius, 0);    
        _gsCache[groupThreadID.y] = _Source[sourceUV]; 
    }
    else if (groupThreadID.y >= DEF_ThreadCount - (uint)blurRadius) 
    {
        sourceUV.y = min(sourceUV.y + blurRadius, sourceSize.y - 1); 
        _gsCache[groupThreadID.y + 2 * blurRadius] = _Source[sourceUV];
    }

    GroupMemoryBarrierWithGroupSync(); 

    float3 col = 0.0f;
    [unroll(DEF_BlurSigma)]
    for (int i = 0; i < DEF_BlurSigma; i++)
    {
        col += _gsCache[groupThreadID.y + i] * _Weights[i];
    }
    
    _Output_Vertical[uint2(dispatchThreadId.x, dispatchThreadId.y)] = col;
}





  /*float3 col = 0;
    uint index = 0;
    int loopCount = (blurRadius - 1) * 0.5f;

    [unroll(9)]
    for (int j = -loopCount; j <= loopCount; j++) 
    {
        int offset = j * 1;   
        int2 sourceUV = dispatchThreadId.xy + int2(offset, 0);

        if (groupThreadID.x < loopCount)  
        {
            int x = max(sourceUV.x - loopCount, 0);    
            sourceUV = int2(x, sourceUV.y);   
        }
        else if (groupThreadID.x >= threadCount - loopCount) 
        {
            int x = min(sourceUV.x + loopCount, sourceSize.x - 1); 
            sourceUV = int2(x,  sourceUV.y);    
        }

         col += Source[sourceUV] * Weights[index];
        index++;
    }
    Output_Horizontal[dispatchThreadId.xy] = col; */
    
   /* int2 sourceUV = dispatchThreadId.xy;
    sourceUV.x = min(sourceUV.x, sourceSize.x -1);
    sourceUV.y = min(sourceUV.y, sourceSize.y -1);

    int loopCount = (blurRadius - 1) * 0.5f;
    if (groupThreadID.x < loopCount)  
    {
        int x = max(sourceUV.x - loopCount, 0);    
        sourceUV = int2(x, sourceUV.y);   
    }
    else if (groupThreadID.x >= threadCount - loopCount) 
    {
        int x = min(sourceUV.x + loopCount, sourceSize.x - 1); 
        sourceUV = int2(x,  sourceUV.y);    
    }*/
